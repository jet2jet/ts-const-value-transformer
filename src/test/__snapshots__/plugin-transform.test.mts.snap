// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`use transformer in "plugins" run tspc: emit file 'index.mjs' 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';
const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
// will be replaced by actual string literal if hoistConstTemplateLiteral is true
const constValue12 = \`ccc\${constValue4}\`;
let writableValue1 = true;
console.log(1 /* constValue1 */, 0.1 /* constValue2 */, (-1) /* constValue3 */, 
/* the comment */
/* the comment */
"foo" /* constValue4 */, 
/* the comment */
true /* constValue5 */, 10n /* constValue6 */ /* the comment */, -10n /* constValue7 */, 
/* the comment */
"aaa\\nbbb" /* constValue8 */.toString() /* the comment */, 
// don't transform because constValue9 is not a literal type
constValue9.toString(), 
// don't transform for asserted type
n.toString(), true /* constValue10 */, 
// 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
(void 0) /* constValue11 */ || 12345, "cccfoo" /* constValue12 */, 
// 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */, 
// writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
writableValue1);
export { constValue1, constValue2, constValue3, constValue4, constValue5, constValue6, constValue7, constValue8, constValue9, };
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
    console.log('');
}
// Test code for print
console.log(-(-1) /* constValue3 */, -1 /* constValue1 */.toString(), 0.1 /* constValue2 */.toString(), (-1) /* constValue3 */.toString(), true /* constValue10 */.toString());
function setWritableValue1() {
    writableValue1 = !!Math.random();
}
// External values
console.log(133 /* ts.SyntaxKind.AnyKeyword */, ts.versionMajorMinor, "5.5" /* versionMajorMinor */, "5.5" /* vmm */);
console.log(mod.Hoge, n === mod.Hoge || n === mod.Piyo);
export const constObject = {
    a: 4,
    b: 'bar',
    c: false,
    d: null,
    e: (void 0) /* undefined */,
    f: 20n,
    g: -30n,
    h: {
        h1: 1 /* constValue1 */,
        h2: -3.14,
        h3: {},
    },
};
console.log(constObject.a, constObject.b, constObject.c, constObject.d, constObject.e, constObject.f, constObject.g, constObject.h, constObject.h.h1, constObject.h.h2, constObject.h.h3, 
//
constObject.a.toString(), constObject.b.toString(), constObject.c.toString(), constObject.f.toString(), constObject.g.toString(), constObject.h.h1.toString(), constObject.h.h2.toString(), 
// element accesses are hoistable by default
constObject['a'], constObject['d']);
console.log(o.a);
console.log(o['a']);
console.log(o.h.h1);
console.log(o.h['h1']);
const nonConstObject = {
    a: true,
    b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);
const partialConstObject = {
    p: 1,
    q: 'q',
    r: {
        s: false,
        t: 2,
    },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(partialConstObject.p, partialConstObject.q, partialConstObject.r.s, partialConstObject.r.t);
var BarEnum;
(function (BarEnum) {
    BarEnum[BarEnum["A"] = 1] = "A";
    BarEnum["B"] = "hoge";
})(BarEnum || (BarEnum = {}));
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);
var BazEnum;
(function (BazEnum) {
    BazEnum[BazEnum["C"] = 2] = "C";
    BazEnum["D"] = "piyo";
})(BazEnum || (BazEnum = {}));
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);
// Type is enum literal, not actual literal type
const valueUsingEnumValue = 1 /* BarEnum.A */;
console.log(1 /* valueUsingEnumValue */);
// Enum type (not enum literal) is not a constant
const valueTypedEnum = Math.floor(Math.random() * 2) >= 1 ? 1 /* BarEnum.A */ : "hoge" /* BarEnum.B */;
console.log(valueTypedEnum);
// Element access with constant name
const name_a = 'a';
console.log(constObject["a" /* name_a */]);
// Nested element access
const tempObjForElementAccess = {
    o: 'a',
    p: 'o',
    q: 'p',
    r: 'q',
};
console.log(constObject[tempObjForElementAccess[tempObjForElementAccess[tempObjForElementAccess[tempObjForElementAccess.r]]]]);
// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 };
console.log(objWithComputedName["a" /* name_a */]);
(() => {
    const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
    console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();
((x = 0.1 /* constValue2 */) => {
    console.log(x);
})();
function fn2() {
    return 12345;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());
// don't transform spread element and parameter declarations
console.log([...Array(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args) => args.length;
console.log(fn1(...Array(5)));
// don't transform omitted expression
const tuple = [1, 2];
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);
// don't transform satisfies expression
2 /* tuple2 */;
switch (tuple2) {
    case 2:
        break;
    default:
        tuple2;
        break;
}
// don't transform assignment
const record1 = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);
// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */];
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */];
const object1 = {
    x: (-1) /* constValue3 */,
    constValue4,
    y: mod.Hoge,
    z: "hoge" /* BarEnum.B */,
};
console.log(1 /* value1 */, array1, array2, object1);
// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */]; // do transform
const as_2 = constObject.b; // do transform
const as_3 = [1 /* BarEnum.A */, "hoge" /* BarEnum.B */].includes(2); // do transform
const as_4 = constObject.b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);
// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(constObject[
// here
'f']);
function multilineTest() {
    return constObject[
    /* here */
    'a'].toFixed(2);
}
console.log(multilineTest());
export {};
//# sourceMappingURL=index.mjs.map"
`;

exports[`use transformer in "plugins" run tspc: emit file 'mod.mjs' 1`] = `
"export const Hoge = 1;
export const Piyo = 2;
//# sourceMappingURL=mod.mjs.map"
`;

exports[`use transformer in "plugins" run tspc: emitted files 1`] = `
[
  "index.d.mts",
  "index.mjs",
  "index.mjs.map",
  "mod.d.mts",
  "mod.mjs",
  "mod.mjs.map",
]
`;
