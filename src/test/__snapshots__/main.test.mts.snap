// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`createTransformer and printSourceWithMap test with default options: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEhB,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBgB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfnC,sBAAW;cACrBoC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRvC,qBAAW;;;;;;;;;;;;oDAY2BwC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS1C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXY,gBAAQ;KACRgB,sBAAS;;YAEFa,cAAM;;;cAGJ3C,mBAAW,EAAEC,qBAAW;aACzBgB,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with default options: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistEnumValues=false: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;;EAUZE,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEf,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBe,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;;;;;;;;;;;;;YAmBZC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGf5B,sBAAW;cACrB6B,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRhC,qBAAW;;;;;;;;;;;;oDAY2BiC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBSnC,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXW,gBAAQ;;;YAGDuB,cAAM;;;cAGJpC,mBAAW,EAAEC,qBAAW;aACzBe,yBAAa;;;8BAGIqB,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistEnumValues=false: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistExternalValues=false and additionalExternalDirectories: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;;;;;;;;;;;;;;KAsBTT,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBU,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGf7B,sBAAW;cACrB8B,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRjC,qBAAW;;;;;;;;;;;;oDAY2BkC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBSpC,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;;KAGXsB,sBAAS;;YAEFa,cAAM;;;cAGJrC,mBAAW,EAAEC,qBAAW;aACzBU,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistExternalValues=false and additionalExternalDirectories: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: mod.Hoge,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistExternalValues=false: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;;;;;;;YAeFE,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEZ,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBY,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGf/B,sBAAW;cACrBgC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRnC,qBAAW;;;;;;;;;;;;oDAY2BoC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBStC,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXQ,gBAAQ;KACRgB,sBAAS;;YAEFa,cAAM;;;cAGJvC,mBAAW,EAAEC,qBAAW;aACzBY,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistExternalValues=false: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistProperty=false: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;;EAExBC,6BAAiB;EACjBC,eAAG;;;;;;;;;;KAUAb,wBAAS;;;;QAINC,mBAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YA4EPa,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;wBAIdC,gBAAM;;;+BAGCA,gBAAM;gCACLA,gBAAM;;;wBAGdjB,sBAAW;cACrBkB,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRrB,qBAAW;;;;;;;;;;;;oDAY2BsB,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBSxB,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;;KAGXY,sBAAS;;YAEFW,cAAM;;;cAGJzB,mBAAW,EAAEC,qBAAW;;cAExBY,iBAAS,YAAYC,sBAAS;;8BAEdY,gBAAI",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "versionMajorMinor",
    "vmm",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "name_a",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistProperty=false: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  ts.versionMajorMinor,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(constObject["a" /* name_a */]);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(objWithComputedName["a" /* name_a */]);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: mod.Hoge,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistPureFunctionCall: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEhB,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBgB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfnC,sBAAW;cACrBoC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRvC,qBAAW;;;;;;;;;0BASCwC,iBAAK,gBAAgBA,iBAAK;;;oDAGAC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS3C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXY,gBAAQ;KACRgB,sBAAS;;YAEFc,cAAM;;;cAGJ5C,mBAAW,EAAEC,qBAAW;aACzBgB,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEde,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "fn2()",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistPureFunctionCall: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ 12345 /* fn2() */, /*#__PURE__*/ 12345 /* fn2() */);

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with hoistUndefinedSymbol=false: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;;;;;EAqBEA,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;;;;;QAWtEf,mBAAW;;;;;;EAMjBgB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfnC,sBAAW;cACrBoC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRvC,qBAAW;;;;;;;;;;;;oDAY2BwC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS1C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXY,gBAAQ;KACRgB,sBAAS;;YAEFa,cAAM;;;cAGJ3C,mBAAW,EAAEC,qBAAW;aACzBgB,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with hoistUndefinedSymbol=false: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistAsExpresion: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;GAIVC,gBAAO;EACRC,uBAAY;;EAEZC,2BAAY;;EAEZV,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXO,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEjB,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBiB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;YAKNC,mCAA2B;YAC3BC,sCAA8B;YAC9BC,sCAA8B;YAC9BC,yCAAiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgC3CC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfxC,sBAAW;cACrByC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGR5C,qBAAW;;;;;SAKhB6C,0BAAc;;;;;;;oDAO6BC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBShD,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXa,gBAAQ;KACRoB,sBAAS;;YAEFc,cAAM;;;cAGJjD,mBAAW,EAAEC,qBAAW;aACzBiB,yBAAa;cACZgB,iBAAS,YAAYC,sBAAS;aAC/Be,oDAAwC;8BACvBC,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "n as 10",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "(o as typeof constObject).a",
    "(o as typeof constObject)['a']",
    "(o as typeof constObject).h.h1",
    "(o as typeof constObject).h['h1']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "12345 as const",
    "u",
    "tuple2",
    "value1",
    "(constObject as { readonly b: 'bar' }).b",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistAsExpresion: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (10 /* n as 10 */).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log(4 /* (o as typeof constObject).a */);
console.log(4 /* (o as typeof constObject)['a'] */);
console.log(1 /* (o as typeof constObject).h.h1 */);
console.log(1 /* (o as typeof constObject).h['h1'] */);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 /* 12345 as const */;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = "bar" /* (constObject as { readonly b: 'bar' }).b */; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistFunctionCall: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEhB,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBgB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfnC,sBAAW;cACrBoC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRvC,qBAAW;;;;;;;YAObwC,iBAAK;;0BAESA,iBAAK,gBAAgBA,iBAAK;;;oDAGAC,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS3C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXY,gBAAQ;KACRgB,sBAAS;;YAEFc,cAAM;;;cAGJ5C,mBAAW,EAAEC,qBAAW;aACzBgB,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEde,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "fn2()",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistFunctionCall: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(12345 /* fn2() */);
// with annotation
console.log(/*@__PURE__*/ 12345 /* fn2() */, /*#__PURE__*/ 12345 /* fn2() */);

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistWritableValues=true: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,wBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,2BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;EAEvCQ,yBAAc;;;;;;;;;;;;;;IAcZV,mBAAW,KAAKU,yBAAc,KAAKN,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZG,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEjB,wBAAS;;;;QAINC,mBAAW;;;;;;EAMjBiB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,4BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;YAiBNC,4BAAgB;;;;;;;;;;;;;;;;;;;;;;EAsB1BC,+BAAoB;EACpBC,8BAAoB;EACpBC,iCAAsB;EACtBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfvC,sBAAW;cACrBwC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGR3C,qBAAW;;;;;;;;;;;;oDAY2B4C,gBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS9C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXa,gBAAQ;KACRmB,sBAAS;;YAEFa,cAAM;;;cAGJ/C,mBAAW,EAAEC,qBAAW;aACzBiB,yBAAa;cACZe,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "writableValue1",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "nonConstObject.a",
    "partialConstObject.p",
    "partialConstObject.q",
    "partialConstObject.r.s",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with unsafeHoistWritableValues=true: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = (void 0) /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  (void 0) /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  true /* writableValue1 */
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (true /* writableValue1 */ || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: (void 0) /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  (void 0) /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(false /* nonConstObject.a */, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  null /* partialConstObject.p */,
  "q" /* partialConstObject.q */,
  true /* partialConstObject.r.s */,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => ((void 0) /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;

exports[`createTransformer and printSourceWithMap test with useUndefinedSymbolForUndefinedValue=true: source map object 1`] = `
{
  "mappings": ";;;;;;;;;;;;;;;;;qBAiBqBA,yBAAS;;;;EAI5BC,mBAAW;EACXC,qBAAW;EACXC,sBAAW;;;EAGXC,uBAAW;;EAEXC,sBAAW;EACXC,qBAAW;EACXC,sBAAW;;EAEXC,4BAAW;;;;;EAKXC,uBAAY;;EAEZC,4BAAY;;EAEZT,mBAAW,GAAGC,qBAAW,GAAGC,sBAAW;;;;;;;;;;;;;;;;IAgBrCF,mBAAW,wBAAwBI,sBAAW;;;;;;GAM/CF,sBAAW;GACXF,mBAAW;EACZC,qBAAW;EACXC,sBAAW;EACXM,uBAAY;;;;;;;;;EASZE,kCAAwB;EACxBC,gCAAoB;EACpBC,6BAAiB;EACjBC,eAAG;;;YAGOC,gBAAQ,oBAAoBA,gBAAQ,sBAAsBC,gBAAQ;;;;;;;KAOzEhB,yBAAS;;;;QAINC,mBAAW;;;;;;EAMjBgB,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbC,wBAAa;EACbC,6BAAa;EACbC,uBAAa;EACbC,wBAAa;;EAEbC,wBAAgB;EAChBC,8BAAgB;;;EAGhBR,qBAAa;EACbC,yBAAa;EACbC,yBAAa;EACbG,uBAAa;EACbC,wBAAa;EACbC,wBAAgB;EAChBC,8BAAgB;;EAEhBC,wBAAgB;EAChBC,2BAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwChBC,8BAAoB;;EAEpBC,8BAAsB;;;;;;;YAOZC,iBAAS,EAAEC,sBAAS;;;;;;YAMpBC,iBAAS,EAAEC,sBAAS;;YAEpBC,oBAAY,EAAEC,yBAAY;;;;YAI1BC,2BAAmB;;;+BAGAC,gBAAM;YACzBC,qCAA2B;;;wBAGfnC,sBAAW;cACrBoC,SAAC,EAAEC,cAAE,EAAEC,YAAC;;;cAGRvC,qBAAW;;;;;;;;;;;;oDAY2BwC,iBAAC;;;;;;;YAOzCC,cAAM;;;AAGlBA,cAAM;;;;;;;;;;;;;;;;;eAiBS1C,mBAAW;gBACVA,mBAAW,EAAEC,qBAAW;gBACxBC,sBAAW,EAAEC,uBAAW;;;;KAInCD,sBAAW;;KAEXY,gBAAQ;KACRgB,sBAAS;;YAEFa,cAAM;;;cAGJ3C,mBAAW,EAAEC,qBAAW;aACzBgB,yBAAa;cACZY,iBAAS,YAAYC,sBAAS;;8BAEdc,gBAAI;;;;;EAKhCC;;;GAGC;;;SAGMC;;;GAGN",
  "names": [
    "undefined",
    "constValue1",
    "constValue2",
    "constValue3",
    "constValue4",
    "constValue5",
    "constValue6",
    "constValue7",
    "constValue8",
    "constValue10",
    "constValue11",
    "ts.SyntaxKind.AnyKeyword",
    "ts.versionMajorMinor",
    "versionMajorMinor",
    "vmm",
    "mod.Hoge",
    "mod.Piyo",
    "constObject.a",
    "constObject.b",
    "constObject.c",
    "constObject.d",
    "constObject.e",
    "constObject.f",
    "constObject.g",
    "constObject.h.h1",
    "constObject.h.h2",
    "constObject['a']",
    "constObject['d']",
    "partialConstObject.q",
    "partialConstObject.r.t",
    "BarEnum.A",
    "BarEnum.B",
    "BazEnum.C",
    "BazEnum.D",
    "BazEnum['C']",
    "BazEnum['D']",
    "constObject[name_a]",
    "name_a",
    "objWithComputedName[name_a]",
    "a",
    "b2",
    "e",
    "u",
    "tuple2",
    "value1",
    "as_4",
    "constObject[
    // here
    'f'
  ]",
    "constObject[
    /* here */
    'a'
  ]",
  ],
  "sources": [
    "index.mts",
  ],
  "sourcesContent": [
    "import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined;
let writableValue1 = true;

console.log(
  constValue1,
  constValue2,
  constValue3,
  /* the comment */
  /* the comment */
  constValue4,
  /* the comment */
  constValue5,
  constValue6 /* the comment */,
  constValue7,
  /* the comment */
  constValue8.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  constValue10,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  constValue11 || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  constValue1 ? constValue2 : constValue3,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (constValue1 && (writableValue1 || !constValue5)) {
  console.log('');
}

// Test code for print
console.log(
  -constValue3,
  -constValue1.toString(),
  constValue2.toString(),
  constValue3.toString(),
  constValue10.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  ts.SyntaxKind.AnyKeyword,
  ts.versionMajorMinor,
  versionMajorMinor,
  vmm
);

console.log(mod.Hoge, (n as number) === mod.Hoge || (n as number) === mod.Piyo);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined,
  f: 20n,
  g: -30n,
  h: {
    h1: constValue1,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  constObject.a,
  constObject.b,
  constObject.c,
  constObject.d,
  constObject.e,
  constObject.f,
  constObject.g,
  constObject.h,
  constObject.h.h1,
  constObject.h.h2,
  constObject.h.h3,
  //
  constObject.a.toString(),
  constObject.b.toString(),
  constObject.c.toString(),
  constObject.f.toString(),
  constObject.g.toString(),
  constObject.h.h1.toString(),
  constObject.h.h2.toString(),
  // element accesses are hoistable by default
  constObject['a'],
  constObject['d']
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  partialConstObject.q,
  partialConstObject.r.s,
  partialConstObject.r.t
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(BarEnum.A, BarEnum.B);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(BazEnum.C, BazEnum.D);
// element access
console.log(BazEnum['C'], BazEnum['D']);

// Element access with constant name
const name_a = 'a';
console.log(constObject[name_a]);

// Object initializer with computed name
const objWithComputedName = { [name_a]: 432 } as const;
console.log(objWithComputedName[name_a]);

(() => {
  const { a, b: b2, e = constValue3 } = constObject;
  console.log(a, b2, e);
})();

((x: number = constValue2) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (u == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(tuple2);

// don't transform satisfies expression
tuple2 satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = constValue1;
const array1 = [constValue1, constValue2] as const;
const array2 = [constValue3, constValue4] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: constValue3,
  constValue4,
  y: mod.Hoge,
  z: BarEnum.B,
} satisfies Record<string, unknown>;
console.log(value1, array1, array2, object1);

// for \`as\` expression
const as_1 = [constValue1, constValue2] as number[]; // do transform
const as_2 = constObject.b as string; // do transform
const as_3 = [BarEnum.A as number, BarEnum.B as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, as_4);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  constObject[
    // here
    'f'
  ] as unknown
);
function multilineTest() {
  return constObject[
    /* here */
    'a'
  ].toFixed(2);
}
console.log(multilineTest());

export {};
",
  ],
  "version": 3,
}
`;

exports[`createTransformer and printSourceWithMap test with useUndefinedSymbolForUndefinedValue=true: transformed source 1`] = `
"import * as ts from 'typescript';
import { versionMajorMinor as vmm } from 'typescript';
import { versionMajorMinor } from 'typescript';
import * as mod from './mod.mjs';

const constValue1 = 1;
const constValue2 = 0.1;
const constValue3 = -1;
const constValue4 = 'foo';
const constValue5 = true;
const constValue6 = 10n;
const constValue7 = -10n;
const constValue8 = \`aaa
bbb\`;
declare let n: number;
const constValue9 = \`bbb\${n}\`;
const constValue10 = !0;
const constValue11 = undefined /* undefined */;
let writableValue1 = true;

console.log(
  1 /* constValue1 */,
  0.1 /* constValue2 */,
  (-1) /* constValue3 */,
  /* the comment */
  /* the comment */
  "foo" /* constValue4 */,
  /* the comment */
  true /* constValue5 */,
  10n /* constValue6 */ /* the comment */,
  -10n /* constValue7 */,
  /* the comment */
  "aaa\\nbbb" /* constValue8 */.toString() /* the comment */,
  // don't transform because constValue9 is not a literal type
  constValue9.toString(),
  // don't transform for asserted type
  (n as 10).toString(),
  true /* constValue10 */,
  // 'constValue11 || 12345' is literal type, but don't transform (instead transform 'constValue11')
  undefined /* constValue11 */ || 12345,
  // 'constValue1 ? constValue2 : constValue3' is literal type, but don't transform
  1 /* constValue1 */ ? 0.1 /* constValue2 */ : (-1) /* constValue3 */,
  // writableValue1 is literal type, but don't transform unless \`unsafeHoistWritableValues\` is true
  writableValue1
);
export {
  constValue1,
  constValue2,
  constValue3,
  constValue4,
  constValue5,
  constValue6,
  constValue7,
  constValue8,
  constValue9,
};
setWritableValue1();
if (1 /* constValue1 */ && (writableValue1 || !true /* constValue5 */)) {
  console.log('');
}

// Test code for print
console.log(
  -(-1) /* constValue3 */,
  -1 /* constValue1 */.toString(),
  0.1 /* constValue2 */.toString(),
  (-1) /* constValue3 */.toString(),
  true /* constValue10 */.toString()
);

function setWritableValue1() {
  writableValue1 = !!Math.random();
}

// External values
console.log(
  133 /* ts.SyntaxKind.AnyKeyword */,
  "5.5" /* ts.versionMajorMinor */,
  "5.5" /* versionMajorMinor */,
  "5.5" /* vmm */
);

console.log(1 /* mod.Hoge */, (n as number) === 1 /* mod.Hoge */ || (n as number) === 2 /* mod.Piyo */);

export const constObject = {
  a: 4,
  b: 'bar',
  c: false,
  d: null,
  e: undefined /* undefined */,
  f: 20n,
  g: -30n,
  h: {
    h1: 1 /* constValue1 */,
    h2: -3.14,
    h3: {},
  },
} as const;
console.log(
  4 /* constObject.a */,
  "bar" /* constObject.b */,
  false /* constObject.c */,
  null /* constObject.d */,
  undefined /* constObject.e */,
  20n /* constObject.f */,
  -30n /* constObject.g */,
  constObject.h,
  1 /* constObject.h.h1 */,
  (-3.14) /* constObject.h.h2 */,
  constObject.h.h3,
  //
  4 /* constObject.a */.toString(),
  "bar" /* constObject.b */.toString(),
  false /* constObject.c */.toString(),
  20n /* constObject.f */.toString(),
  -30n /* constObject.g */.toString(),
  1 /* constObject.h.h1 */.toString(),
  (-3.14) /* constObject.h.h2 */.toString(),
  // element accesses are hoistable by default
  4 /* constObject['a'] */,
  null /* constObject['d'] */
);

// don't transform here unless unsafeHoistAsExpresion is true
declare let o: object;
console.log((o as typeof constObject).a);
console.log((o as typeof constObject)['a']);
console.log((o as typeof constObject).h.h1);
console.log((o as typeof constObject).h['h1']);

const nonConstObject = {
  a: true,
  b: 1,
};
nonConstObject.a = false;
nonConstObject.b = 2;
// don't transform \`a\` unless \`unsafeHoistWritableValues\` is true
console.log(nonConstObject.a, nonConstObject.b);

interface WithReadonlyObject {
  p: number | null;
  readonly q: 'q';
  readonly r: {
    s: boolean;
    readonly t: 2;
  };
}
const partialConstObject: WithReadonlyObject = {
  p: 1,
  q: 'q',
  r: {
    s: false,
    t: 2,
  },
};
partialConstObject.p = null;
partialConstObject.r.s = true;
// don't transform \`p\` and \`r.s\` unless \`unsafeHoistWritableValues\` is true
console.log(
  partialConstObject.p,
  "q" /* partialConstObject.q */,
  partialConstObject.r.s,
  2 /* partialConstObject.r.t */
);

const enum BarEnum {
  A = 1,
  B = 'hoge',
}
console.log(1 /* BarEnum.A */, "hoge" /* BarEnum.B */);

enum BazEnum {
  C = 2,
  D = 'piyo',
}
console.log(2 /* BazEnum.C */, "piyo" /* BazEnum.D */);
// element access
console.log(2 /* BazEnum['C'] */, "piyo" /* BazEnum['D'] */);

// Element access with constant name
const name_a = 'a';
console.log(4 /* constObject[name_a] */);

// Object initializer with computed name
const objWithComputedName = { ["a" /* name_a */]: 432 } as const;
console.log(432 /* objWithComputedName[name_a] */);

(() => {
  const { a, b: b2, e = (-1) /* constValue3 */ } = constObject;
  console.log(4 /* a */, "bar" /* b2 */, (-1) /* e */);
})();

((x: number = 0.1 /* constValue2 */) => {
  console.log(x);
})();

function fn2() {
  return 12345 as const;
}
console.log(fn2());
// with annotation
console.log(/*@__PURE__*/ fn2(), /*#__PURE__*/ fn2());

// don't transform spread element and parameter declarations
console.log([...Array<undefined>(5)].map((u, i) => (undefined /* u */ == null ? i : 0)));
const fn1 = (...args: undefined[]) => args.length;
console.log(fn1(...Array<undefined>(5)));

// don't transform omitted expression
const tuple = [1, 2] as const;
const [, tuple2] = tuple;
console.log(2 /* tuple2 */);

// don't transform satisfies expression
2 /* tuple2 */ satisfies 2;
switch (tuple2) {
  case 2:
    break;
  default:
    tuple2 satisfies never;
    break;
}

// don't transform assignment
const record1: Record<string, true> = {};
record1.foo = true;
record1['bar'] = true;
// don't transform indexed access
console.log(record1.foo, record1.baz);

// do transform constant values in initializers
const value1 = 1 /* constValue1 */;
const array1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as const;
const array2 = [(-1) /* constValue3 */, "foo" /* constValue4 */] as const satisfies ReadonlyArray<
  string | number
>;
const object1 = {
  x: (-1) /* constValue3 */,
  constValue4,
  y: 1 /* mod.Hoge */,
  z: "hoge" /* BarEnum.B */,
} satisfies Record<string, unknown>;
console.log(1 /* value1 */, array1, array2, object1);

// for \`as\` expression
const as_1 = [1 /* constValue1 */, 0.1 /* constValue2 */] as number[]; // do transform
const as_2 = "bar" /* constObject.b */ as string; // do transform
const as_3 = [1 /* BarEnum.A */ as number, "hoge" /* BarEnum.B */ as string].includes(2); // do transform
const as_4 = (constObject as { readonly b: 'bar' }).b; // don't transform unless unsafeHoistAsExpresion
console.log(as_1, as_2, as_3, "bar" /* as_4 */);

// for multiline expression
// e.g. \`as XXX\` requires to have an expression in the same line ('X as Y' is ok, 'X\\n as Y' is invalid)
console.log(
  (20n /* constObject[
    // here
    'f'
  ] */) as unknown
);
function multilineTest() {
  return (4 /* constObject[
     * here * 
    'a'
  ] */).toFixed(2);
}
console.log(multilineTest());

export {};
"
`;
